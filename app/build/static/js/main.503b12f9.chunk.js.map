{"version":3,"sources":["Client.js","components/App.jsx","index.js"],"names":["src_Client","Client","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","socket","pin","_this2","isConnected","WebSocket","addEventListener","emit","onData","bind","evt","_this3","data","split","forEach","msg","type","json","JSON","parse","err","processResponse","text","from","send","stringify","close","readyState","EventEmitter","App","_React$Component","props","outputRef","React","createRef","inputRef","inherits","createClass","key","value","on","updateChat","concat","connect","elem","current","chat","scrollTop","scrollHeight","keyCode","sendChat","react_default","a","createElement","className","Container","ref","readOnly","onKeyUp","onInput","Component","ReactDOM","render","App_App","document","querySelector"],"mappings":"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","file":"static/js/main.503b12f9.chunk.js","sourcesContent":["// imports\r\nimport { EventEmitter } from \"events\";\r\n\r\nconst DELIM = \"*!*\";    // json message delimiter\r\n\r\n// client class holds the websocket connection and handles sending/receiving data\r\nclass Client extends EventEmitter{\r\n    constructor(){\r\n        super();\r\n\r\n        this.socket = null;     // websocket \r\n        this.pin = null;        // server-generated unique pin\r\n    }\r\n\r\n    // connects to the server\r\n    connect(){\r\n        // only connect if not connected\r\n        if(!this.isConnected){\r\n            let url = \"ws://localhost:8080\";\r\n\r\n            // create the websocket (auto-connects)\r\n            this.socket = new WebSocket(url);\r\n\r\n            // when the websocket connects...\r\n            this.socket.addEventListener(\"open\", () => {\r\n                this.emit(\"connected\");\r\n            });\r\n\r\n            // when the websocket receives server data...\r\n            this.socket.addEventListener(\"message\", this.onData.bind(this));\r\n\r\n            // when the websocket has a fatal error...\r\n            this.socket.addEventListener(\"error\", () => {\r\n                this.emit(\"error\");\r\n            });\r\n\r\n            // when the websocket closes...\r\n            this.socket.addEventListener(\"close\", () => {\r\n                this.emit(\"close\");\r\n            });\r\n        }\r\n    }\r\n\r\n    // parses data from the server\r\n    onData(evt){\r\n        // data can be sent concatenated - split on delimiter \r\n        evt.data.split(DELIM).forEach(msg => {\r\n            // extract type and data\r\n            let type, data;\r\n            try{\r\n                // attempt parse json\r\n                let json = JSON.parse(msg);\r\n\r\n                // got json - extract type and data\r\n                type = json.type || null;\r\n                data = json.data || null;\r\n            }\r\n            catch(err){\r\n                // json parse error\r\n                return;\r\n            }\r\n\r\n            // process response using type and data\r\n            this.processResponse(type, data);\r\n        });\r\n    }\r\n\r\n    // processes a server response\r\n    processResponse(type, data){\r\n        switch(type){\r\n            case \"chat\":\r\n                let {text, from} = data;\r\n                this.emit(\"chat\", {text, from});\r\n                break;\r\n            case \"pin\":\r\n                let {pin} = data;\r\n                this.pin = pin;\r\n                this.emit(\"pin\");\r\n            default:\r\n                break;\r\n        }\r\n    }\r\n\r\n    // sends chat request\r\n    sendChat(text){\r\n        this.send(\"chat\", {text});\r\n    }\r\n\r\n    // sends a formatted string to the server\r\n    send(type, data){\r\n        if(this.isConnected){\r\n            this.socket.send(JSON.stringify({type, data}) + DELIM)\r\n        }\r\n    }\r\n\r\n    // closes the websocket if it can\r\n    close(){\r\n        if(this.isConnected){\r\n            this.socket.close();\r\n        }\r\n    }\r\n\r\n    // getter for is connected\r\n    get isConnected(){\r\n        return this.socket ? this.socket.readyState === 1 : false;\r\n    }\r\n}\r\n\r\n// export singleton\r\nexport default new Client();","import React from \"react\";\r\nimport { Container } from \"reactstrap\";\r\nimport Client from \"../Client\";\r\nimport \"./App.css\";\r\n\r\nexport class App extends React.Component{\r\n    constructor(props){\r\n        super(props);\r\n\r\n        // refs \r\n        this.outputRef = React.createRef();\r\n        this.inputRef = React.createRef();\r\n    }\r\n\r\n    // when the component mounts...\r\n    componentDidMount(){\r\n        // client handlers\r\n        // (these should be removed on unmount... but app won't unmount)\r\n        Client.on(\"connected\", () => this.updateChat(\"Connected to server.\"));\r\n        Client.on(\"close\", () => this.updateChat(\"Lost connection.\"));\r\n        Client.on(\"pin\", () => this.updateChat(`PIN = ${Client.pin}`));\r\n        Client.on(\"chat\", evt => this.updateChat(evt.text, evt.from));\r\n\r\n        // immediately connect to the server\r\n        this.updateChat(\"Connecting...\");\r\n        Client.connect();\r\n    }\r\n\r\n    // updates the chat output element \r\n    updateChat(text, from){\r\n        // the actual <textarea>\r\n        let elem = this.outputRef.current;\r\n        // format chat string \r\n        let chat = from ? `${from}: ${text}` : text;\r\n\r\n        // update the element\r\n        if(!elem.value){\r\n            // empty - just paste text\r\n            elem.value = chat;\r\n        }\r\n        else{\r\n            // not empty - append text to bottom\r\n            elem.value = `${elem.value}\\n${chat}`;\r\n            \r\n            // scroll to bottom\r\n            elem.scrollTop = elem.scrollHeight;\r\n        }\r\n    }\r\n\r\n    // handle keyboard input\r\n    onInput(evt){\r\n        // get text in the <input>\r\n        let text = this.inputRef.current.value;\r\n\r\n        // if there is text and the key pressed is enter...\r\n        if(text && evt.keyCode === 13){\r\n            // send the chat request\r\n            Client.sendChat(text);\r\n\r\n            // clear the <input>\r\n            this.inputRef.current.value = \"\";\r\n        }\r\n    }\r\n\r\n    // renders the app\r\n    render(){\r\n        return (\r\n            <div>\r\n                <br/>\r\n                <header>\r\n                    <h1 className=\"text-center\">Electron Chat</h1>\r\n                </header>\r\n                <br/>\r\n                <Container>\r\n                    <div className=\"chat\">\r\n                        <textarea ref={this.outputRef} readOnly/>\r\n                        <br/>\r\n                        <input\r\n                            ref={this.inputRef}\r\n                            type=\"text\"\r\n                            onKeyUp={this.onInput.bind(this)}\r\n                        />\r\n                    </div>\r\n                </Container>\r\n            </div>\r\n        );\r\n    }\r\n}","import React from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\nimport { App } from \"./components/App\";\r\nimport \"../node_modules/bootstrap/dist/css/bootstrap.min.css\";\r\n\r\nReactDOM.render(<App/>, document.querySelector(\"#root\"));"],"sourceRoot":""}