{"version":3,"sources":["Client.js","components/App.jsx","index.js"],"names":["src_Client","Client","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","socket","pin","_this2","isConnected","url","getSocketURL","WebSocket","addEventListener","emit","onData","bind","evt","_this3","data","split","forEach","msg","type","json","JSON","parse","err","processResponse","text","from","send","stringify","close","host","window","location","origin","includes","readyState","EventEmitter","App","_React$Component","props","outputRef","React","createRef","inputRef","inherits","createClass","key","value","on","updateChat","concat","connect","elem","current","chat","scrollTop","scrollHeight","keyCode","sendChat","react_default","a","createElement","className","Container","ref","readOnly","onKeyUp","onInput","Component","ReactDOM","render","App_App","document","querySelector"],"mappings":"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","file":"static/js/main.6aa58fc0.chunk.js","sourcesContent":["// imports\r\nimport { EventEmitter } from \"events\";\r\n\r\nconst DELIM = \"*!*\";    // json message delimiter\r\n\r\n// client class holds the websocket connection and handles sending/receiving data\r\nclass Client extends EventEmitter{\r\n    constructor(){\r\n        super();\r\n\r\n        this.socket = null;     // websocket \r\n        this.pin = null;        // server-generated unique pin\r\n    }\r\n\r\n    // connects to the server\r\n    connect(){\r\n        // only connect if not connected\r\n        if(!this.isConnected){\r\n            // get connection url\r\n            let url = this.getSocketURL();\r\n\r\n            // create the websocket (auto-connects)\r\n            this.socket = new WebSocket(url);\r\n\r\n            // when the websocket connects...\r\n            this.socket.addEventListener(\"open\", () => {\r\n                this.emit(\"connected\");\r\n            });\r\n\r\n            // when the websocket receives server data...\r\n            this.socket.addEventListener(\"message\", this.onData.bind(this));\r\n\r\n            // when the websocket has a fatal error...\r\n            this.socket.addEventListener(\"error\", () => {\r\n                this.emit(\"error\");\r\n            });\r\n\r\n            // when the websocket closes...\r\n            this.socket.addEventListener(\"close\", () => {\r\n                this.emit(\"close\");\r\n            });\r\n        }\r\n    }\r\n\r\n    // parses data from the server\r\n    onData(evt){\r\n        // data can be sent concatenated - split on delimiter \r\n        evt.data.split(DELIM).forEach(msg => {\r\n            // extract type and data\r\n            let type, data;\r\n            try{\r\n                // attempt parse json\r\n                let json = JSON.parse(msg);\r\n\r\n                // got json - extract type and data\r\n                type = json.type || null;\r\n                data = json.data || null;\r\n            }\r\n            catch(err){\r\n                // json parse error\r\n                return;\r\n            }\r\n\r\n            // process response using type and data\r\n            this.processResponse(type, data);\r\n        });\r\n    }\r\n\r\n    // processes a server response\r\n    processResponse(type, data){\r\n        switch(type){\r\n            case \"chat\":\r\n                let {text, from} = data;\r\n                this.emit(\"chat\", {text, from});\r\n                break;\r\n            case \"pin\":\r\n                let {pin} = data;\r\n                this.pin = pin;\r\n                this.emit(\"pin\");\r\n            default:\r\n                break;\r\n        }\r\n    }\r\n\r\n    // sends chat request\r\n    sendChat(text){\r\n        this.send(\"chat\", {text});\r\n    }\r\n\r\n    // sends a formatted string to the server\r\n    send(type, data){\r\n        if(this.isConnected){\r\n            this.socket.send(JSON.stringify({type, data}) + DELIM)\r\n        }\r\n    }\r\n\r\n    // closes the websocket if it can\r\n    close(){\r\n        if(this.isConnected){\r\n            this.socket.close();\r\n        }\r\n    }\r\n\r\n    // gets websocket connection url\r\n    getSocketURL(){\r\n        let host = window.location.origin.includes(\"https:\") ? \"wss:\" : \"ws:\";\r\n\r\n        switch(window.location.origin){\r\n            case \"file://\":\r\n                host += \"//electronchat.herokuapp.com/\";\r\n                break;\r\n            case \"localhost\":\r\n                host += \"localhost:8080\";\r\n                break;\r\n            default:\r\n                // duplicate of localhost case incase it changes \r\n                host += \"localhost:8080\";\r\n                break;\r\n        }\r\n\r\n        return host;\r\n    }\r\n\r\n    // getter for is connected\r\n    get isConnected(){\r\n        return this.socket ? this.socket.readyState === 1 : false;\r\n    }\r\n}\r\n\r\n// export singleton\r\nexport default new Client();","import React from \"react\";\r\nimport { Container } from \"reactstrap\";\r\nimport Client from \"../Client\";\r\nimport \"./App.css\";\r\n\r\nexport class App extends React.Component{\r\n    constructor(props){\r\n        super(props);\r\n\r\n        // refs \r\n        this.outputRef = React.createRef();\r\n        this.inputRef = React.createRef();\r\n    }\r\n\r\n    // when the component mounts...\r\n    componentDidMount(){\r\n        // client handlers\r\n        // (these should be removed on unmount... but app won't unmount)\r\n        Client.on(\"connected\", () => this.updateChat(\"Connected to server.\"));\r\n        Client.on(\"close\", () => this.updateChat(\"Lost connection.\"));\r\n        Client.on(\"pin\", () => this.updateChat(`PIN = ${Client.pin}`));\r\n        Client.on(\"chat\", evt => this.updateChat(evt.text, evt.from));\r\n\r\n        // immediately connect to the server\r\n        this.updateChat(\"Connecting...\");\r\n        Client.connect();\r\n    }\r\n\r\n    // updates the chat output element \r\n    updateChat(text, from){\r\n        // the actual <textarea>\r\n        let elem = this.outputRef.current;\r\n        // format chat string \r\n        let chat = from ? `${from}: ${text}` : text;\r\n\r\n        // update the element\r\n        if(!elem.value){\r\n            // empty - just paste text\r\n            elem.value = chat;\r\n        }\r\n        else{\r\n            // not empty - append text to bottom\r\n            elem.value = `${elem.value}\\n${chat}`;\r\n            \r\n            // scroll to bottom\r\n            elem.scrollTop = elem.scrollHeight;\r\n        }\r\n    }\r\n\r\n    // handle keyboard input\r\n    onInput(evt){\r\n        // get text in the <input>\r\n        let text = this.inputRef.current.value;\r\n\r\n        // if there is text and the key pressed is enter...\r\n        if(text && evt.keyCode === 13){\r\n            // send the chat request\r\n            Client.sendChat(text);\r\n\r\n            // clear the <input>\r\n            this.inputRef.current.value = \"\";\r\n        }\r\n    }\r\n\r\n    // renders the app\r\n    render(){\r\n        return (\r\n            <div>\r\n                <br/>\r\n                <header>\r\n                    <h1 className=\"text-center\">Electron Chat</h1>\r\n                </header>\r\n                <br/>\r\n                <Container>\r\n                    <div className=\"chat\">\r\n                        <textarea ref={this.outputRef} readOnly/>\r\n                        <br/>\r\n                        <input\r\n                            ref={this.inputRef}\r\n                            type=\"text\"\r\n                            onKeyUp={this.onInput.bind(this)}\r\n                        />\r\n                    </div>\r\n                </Container>\r\n            </div>\r\n        );\r\n    }\r\n}","import React from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\nimport { App } from \"./components/App\";\r\nimport \"../node_modules/bootstrap/dist/css/bootstrap.min.css\";\r\n\r\nReactDOM.render(<App/>, document.querySelector(\"#root\"));"],"sourceRoot":""}